# 28강) 다이나믹 프로그래밍 개요

## 📍 다이나믹 프로그래밍(= 동적 계획법)

- **메모리를 적절히 사용**하여 **수행 시간 효율성을 비약적으로 향상**시키는 방법
- **이미 계산된 결과**(작은 문제)는 별도의 **메모리 영역에 저장**하여 다시 계산하지 않도록 함
- 완전 탐색으로 매우 비효율적인 시간 복잡도를 갖더라도, 다이나믹 프로그래밍을 통해 시간 복잡도를 획기적으로 줄일 수 있는 경우가 많음
- 일반적으로 `탑다운(하향식)`, `보텀업(상향식)` 두 가지 방식으로 **구현**
- 일반 프로그래밍 분야에서 **동적(Dynamic)**이란?
    - 자료구조 - 동적 할당(Dynamic Allocation): **프로그램이 실행되는 도중에** 실행에 필요한 메모리를 할당하는 기법
    - 다이나믹 프로그래밍에서 ‘다이나믹’은 별다른 의미 없음

## 📍 다이나믹 프로그래밍의 조건

- **최적 부분 구조 (Optimal Substructure)**
    - **큰 문제**를 **작은 문제**로 나눌 수 있으며, **작은 문제의 답을 모아 큰 문제를 해결**할 수 있음
- **중복되는 부분 문제 (Overlapping Subproblem)**
    - **동일한 작은 문제**를 **반복적으로 해결**해야 함

### 📍 피보나치 수열

- 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
- 다이나믹 프로그래밍으로 효과적으로 계산할 수 있음
- **점화식**: **인접한 항**들 사이의 **관계식**
- 피보나치 수열의 점화식: `An = An-1 + An-2`, `A1 = 1`, `A2 = 1`
- 프로그래밍에서는 이러한 수열을 **배열이나 리스트**를 이용해 표현

**피보나치 수열: 단순 재귀 소스코드**

```python
# 피보나치 함수를 재귀함수로 구현
def fibo(x):
		if x == 1 or x == 2:
				return 1
		return fibo(x-1) + fibo(x-2)

print(fibo(4))
```

⇒ **지수 시간 복잡도** → f(30)을 계산하려면 약 10억가량의 연산 수행..

![피보나치다이나믹.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b8adfafe-964a-4e02-acaa-47a8510b2283/피보나치다이나믹.png)

`f(2)`가 **여러번 호출** ⇒ **중복되는 부분 문제 ⇒ 다이나믹 프로그래밍 사용**

## 📍 메모이제이션(Memoization)

- 한 번 계산한 결과를 **메모리 공간에 메모**하는 기법
    - 같은 문제를 다시 호출하면, 메모했던 결과를 그대로 가져옴
    - **캐싱(Caching)**이라고도 함

## 📍 탑다운 vs 보텀업

- **탑다운(= 메모이제이션, 하향식)**: `재귀함수`로 구현
    - 큰 문제를 해결하기 위해 작은 문제를 재귀적으로 호출
- **보텀업(= 상향식)**: `반복문`으로 구현
    - 아래쪽에부터 작은 문제를 하나씩 해결
- 다이나믹 프로그래밍의 **전형적인 형태: 보텀업**
    - **결과 저장**용 리스트는 `DP 테이블`이라고 부름
- 메모이제이션: 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미
    - 다이나믹 프로그래밍에 국한된 개념은 아님
    - 한 번 계산된 결과를 담아 놓기만 하고, 다이나믹 프로그래밍을 위해 활용되지 않을 수도 있음

**피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드**

```python
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
		if x == 1 or x == 2:
				return 1
		# 이미 계산한 적 있는 문제라면 그대로 반환
		if d[x] != 0:
				return d[x]
		# 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
		d[x] = fibo(x-1) + fibo(x-2)
		return d[x]

print(fibo(99))
```

⇒ `O(N)`

**피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드**

```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째, 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 2
n = 99

# 피보나치 함수 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n+1):
		d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

## 📍 다이나믹 프로그래밍 vs 분할 정복

- **공통점**: `최적 부분 구조`를 가질 때 사용할 수 있음
    - 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결할 수 있는 상황
- **차이점**: `부분 문제의 중복`
    - **다이나믹 프로그래밍**: 각 부분 문제들이 서로 영향을 미치며 **부분 문제가 중복됨**
    - **분할 정복**: 동일한 부분 문제가 **반복적으로 계산되지 않음**
        
        ⇒ 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출되지 않음
        

## 📍 다이나믹 프로그래밍 문제에 접근하는 방법

- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 **문제를 해결할 수 있는지 검토**
    - 다른 알고리즘으로 **방법이 떠오르지 않으면 다이나믹 프로그래밍** 고려
- `재귀 함수`로 **비효율적인 완전 탐색** 프로그래밍 작성 ⇒ (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, `코드 개선` 가능
- 일반적인 코테 수준에서는 **기본 유형의 다이나믹 프로그래밍** 문제가 출제되는 경우가 많음


### 📍 출처
이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈