# 29강) 다이나믹 프로그래밍 기초 문제 풀이

## 1. 개미 전사

**📌 문제 설명**

- 일직선으로 이어져 있는 식량창고
- 식량창고 선택적으로 약탈
- 메뚜기 정찰병들은 서로 인접한 식량창고가 공격 받으면 알아챌 수 있음
- 최소 한 칸 이상 떨어진 식량창고 약탈
- 얻을 수 있는 식량의 최댓값

**📌 예시**

4

1 3 1 5

⇒ 최대 8

**📌 설명**

- Ai = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
    - ⇒ 다이나믹 프로그래밍 적용 가능
- 왼쪽부터 차례대로 식량창고를 턴다고 했을 때, 특정한 `i`번째 식량창고에 대해서 털지 안 털지의 여부를 결정하면, `i-1`번째까지의 값과 `i-2`번째까지의 값 중에서 **더 많은 식량을 털 수 있는 경우를 선택**하면 됨
- Ai = i번째 식량창고까지의 최적의 해
- ki = i번째 식량창고에 있는 식량의 양
- **Ai = max(Ai-1, Ai-2 + ki)**

**📌 코드**

```python
# 정수 N
n = int(input())
# 식량 정보
array = list(map(int, input().split()))

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 다이나믹 프로그래밍 진행 (보텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
	d[i] = max(d[i-1], d[i-2] + array[i])

print(d[n-1])
```

## 2. 1로 만들기

**📌 문제 설명**

- 정수 X에 사용할 수 있는 연산
1. X가 5로 나누어 떨어지면 5로 나눔
2. X가 3으로 나누어 떨어지면 3으로 나눔
3. X가 2로 나누어 떨어지면 2로 나눔
4. X에서 1 뺌
- 정수 X가 주어졌을 때, 값을 1로 만들 수 있는 최소 연산 횟수

**📌 예시**

26

⇒ 3 (26 → 25 → 5 → 1)

**📌 설명**

- 6인 경우, 1을 뺀 선택지, 2로 나눈 선택지, 3으로 나눈 선택지를 선택할 수 있듯이 매 상황마다 부분 문제를 확인해보고 가장 작은 값을 도출하면 됨
- Ai = i를 1로 만들기 위한 최소 연산 횟수
- Ai = min(Ai-1, Ai/2, Ai/3, Ai/5) + 1

**📌 코드**

```python
# 정수 X
x = int(input())

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 30001

# 다이나믹 프로그래밍 진행
for i in range(2, x+1)
	# 현재의 수에서 1을 빼는 경우
	d[i] = d[i-1] + 1
	# 현재의 수가 2로 나누어 떨어지는 경우
	if i % 2 == 0:
		d[i] = min(d[i], d[i//2] + 1)
	# 현재의 수가 3으로 나누어 떨어지는 경우
	if i % 3 == 0:
		d[i] = min(d[i], d[i//3] + 1)
	# 현재의 수가 5로 나누어 떨어지는 경우
	if i % 5 == 0:
		d[i] = min(d[i], d[i//5] + 1)

print(d[x])
```

## 3. 효율적인 화폐 구성

**📌 문제 설명**

- N가지 종류 화폐
- M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램 작성

**📌 예시**

2원, 3원 단위의 화폐가 있을 때 15원 ⇒ 3원을 5개 사용

**📌 설명**

- Ai = 금액 i를 만들 수 있는 최소한의 화폐 개수
- k = 각 화폐의 단위
- k를 하나씩 확인하며
    - Ai-k를 만드는 방법이 존재하는 경우, Ai = min(Ai, Ai-k + 1)
    - Ai-k를 만드는 방법이 존재하지 않는 경우, Ai = INF
- 각 인덱스에 INF(무한) 값 설정 ⇒ 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미
    - N = 3, M =7, 화폐 단위 2, 3, 5인 경우
    - 첫 번째 단위인 2부터 확인 ⇒ 2, 4, 6, ... 원은 만들 수 있음 ⇒ 리스트 갱신
    - 두 번째 단위인 3 확인 ⇒ 3원은 0에서 3원 더해서 만들 수 있음. 7원도 4원+3원이니 가능 ⇒ 리스트 갱신
    - 세 번째 단위인 5 확인 ⇒ 리스트 갱신

**📌 코드**

```python
# N, M 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보 받기
array = []
for i in range(n):
	array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 다이나믹 프로그래밍 진행
d[0] = 0
for i in range(n):
	for j in range(array[i], m+1):
		if d[j - array[i]] != 10001:  # (i - k)원을 만드는 방법이 존재하는 경우
			d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001:  # 최종적으로 M원을 만드는 방법이 없는 경우
	print(-1)
else:
	print(d[m])
```

## 4. 금광

**📌 문제 설명**

- n x m 크기의 금광
- 첫 번째 열의 어느 행(상관x)에서부터 출발
- m-1번에 걸쳐 오른쪽 위, 오른쪽, 오른쪽 아래 중 하나의 위치로 이동
- 최대 금의 크기 출력

**📌 설명**

- 금광의 모든 위치에 대하여
    - 왼쪽 위에서 오는 경우
    - 왼쪽 아래에서 오는 경우
    - 왼쪽에서 오는경우

의 경우 중에서 가장 많은 금을 가지고 있는 경우를 테이블에 갱신

- array[i][j] = i행 j열에 존재하는 금의 양
- dp[i][j] = i행 j열까지의 최적의 해
- dp[i][j] = array[i][j] + max(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])
- 테이블에 접근할 때마다 리스트의 범위를 벗어나지 않는지 체크하기

**📌 코드**

```python
# 테스트 케이스 입력
for tx in rnage(int(input())):
	# 금광 정보 입력
	n, m = map(int, input().split())
	array = list(map(int, input().split()))
	# 다이나믹 프로그래밍을 위한 2차원 DP 테이블 초기화
	dp = []
	index = 0
	for i in range(n):
		dp.append(array[index:index + m])
		index += m
	# 다이나믹 프로그래밍 진행
	for j in range(1, m):
		for i in range(n):
			# 왼쪽 위에서 오는 경우
			if i == 0: left_up = 0
			else: left_up = dp[i-1][j-1]
			# 왼쪽 아래에서 오는 경우
			if i == n-1: left_down = 0
			else: left_down = dp[i+1][j-1]
			# 왼쪽에서 오는 경우
			left = dp[i][j-1]
			dp[i][j] = dp[i][j] + max(left_up, left_down, left)
	result = 0
	for i in range(n):
		result = max(result, dp[i][m-1])
	print(result)
			
```


### 📍 출처
이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈