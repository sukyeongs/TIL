# 27강) 이진 탐색 기초 문제 풀이

## 1. 떡볶이 떡 만들기

**📌 문제 설명**

- 떡의 길이 일정 X, 한 봉지 안에 들어가는 떡의 총 길이는 절단기로 잘라서 맞춤
- 절단기에 **높이(H)** 지정 → 줄지어진 떡 한번에 절단
    - 높이가 H보다 긴 떡: H의 윗부분이 잘림
    - 높이가 H보다 낮은 떡: 잘리지 않음
- 손님이 **요청한 길이 M**, 적어도 **M만큼의 떡을 얻기 위해 절단기에 설정할 수 있는 높이의 최댓값** 구하는 프로그램

📌 **예시**

- 19, 14, 10, 17 cm 떡
- 높이 = 15 cm

⇒ 4, 0, 0, 2 cm 잘림 

⇒ 손님 6cm 가져감

**📌 설명**

- 적절한 높이를 찾을 때까지 `이진 탐색`을 수행하여 높이 H를 반복하여 조정
- **‘현재 이 높이로 자르면 조건을 만족할 수 있는가?’**를 확인한 뒤에 조건의 **만족 여부**(’예’ 혹은 ‘아니오’)에 따라서 **탐색 범위를 좁혀서** 해결
- 절단기의 높이는 0부터 `10억`까지의 정수
    - 이렇게 `큰 탐색 범위`를 보면 가장 먼저 `이진 탐색`을 떠올리기
- 예시의 경우
    - 시작점: **0**, 끝점: **19**, 중간점: **9**, 떡의 크기 M: **6**
    - 중간점 9인 경우 ⇒ 잘린 떡의 길이 = 10 + 5 + 1 + 8 = **24**
    - **조건 만족** ⇒ 중간점 9 기록 저장, 높이를 더 높여도 **조건 충족 되는지 확인**
    - 시작점: **10(중간점 다음)**, 끝점: **19**, 중간점: **14**
    - 중간점 14인 경우 ⇒ 잘린 떡의 길이 = 5 + 1 + 3 = **9**
    - **조건 만족** ⇒ 중간점 14 기록 저장, 높이를 더 높여도 **조건 충족 되는지 확인**
    - 시작점: **15(중간점 다음)**, 끝점: **19**, 중간점: **17**
    - 중간점 17인 경우 ⇒ 잘린 떡의 길이 = 2
    - **조건 불만족** ⇒ 중간점 17 기록 저장 X, 끝점을 중간점 전으로 하기
    - 시작점: **15**, 끝점: **16**, 중간점: **15**
    - 중간점 15인 경우 ⇒ 잘린 떡의 길이 = 4 + 2 = 6
    - **조건 만족** ⇒ 중간점 15 기록 저장
- 위와 같은 `이진 탐색` 과정을 `반복`하면 답을 도출할 수 있음
- **중간점**의 값은 시간이 지날수록 ‘**최적화된 값**’이 되기 때문에, 과정을 반복하면서 **얻을 수 있는 떡의 길이 합**이 **필요한 떡의 길이보다 크거나 같을 때**마다 중간점의 값 기록

```python
# 떡의 개수(N)와 요청한 떡의 길이(M) 입력
n, m = list(map(int, input().split(' ')))
# 각 떡의 개별 높이 정보를 입력
array = list(map(int, input().split()))

# 이진 탐색을 위한 시작점과 끝점 설정
start = 0
end = max(array)

# 이진 탐색 수행 (반복적)
result = 0
while(start <= end):
		total = 0
		mid = (start + end) // 2
		for x in array:
				# 잘랐을 때의 떡의 양 계산
				if x > mid:
						total += x - mid
		# 떡의 양이 부족한 경우 더 많이 자르기 (왼쪽 부분 탐색)
		if total < m:
				end = mid - 1
		# 떡의 양이 충분한 경우 덜 자르기 (오른쪽 부분 탐색)
		else:
				result = mid # 최대한 덜 잘랐을 때가 정답이므로, result 기록
				start = mid + 1

# 정답 출력
print(result)
```

## 2. 정렬된 배열에서 특정 수의 개수 구하기

**📌 문제 설명**

- `N`개의 원소를 포함하는 수열이 오름차순으로 정렬
- 이 수열에서 `x`가 **등장하는 횟수** 계산
- 시간 복잡도 `O(logN)`으로 설계할 것

📌 **예시**

- 수열 {1, 1, **2, 2, 2, 2**, 3}, x = 2 ⇒ **4** 출력

**📌 설명**

- 일반적인 선형 탐색으로는 시간 초과 판정을 받음
- 데이터가 정렬 되어 있음 ⇒ `이진 탐색` 수행
- 특정 값이 등장하는 **첫 번째 위치**와 **마지막 위치**를 찾아 위치 차이를 계산하여 문제 해결

```python
from bisect import bisect_left, bisect_right

# 값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(array, left_value, right_value):
		right_index = bisect_right(array, right_value)
		left_index = bisect_left(array, left_value
		return right_index - left_index

n, x = map(int, input().split())  # 데이터의 개수 N, 찾고자 하는 x 입력받기
array = list(map(int, input().split()))  # 전체 데이터 입력 받기

# 값이 [x, x] 범위에 있는 데이터의 개수 계산
count = count_by_range(array, x, x)

# 값이 x인 원소가 존재하지 않는다면
if count == 0:
		print(-1)
# 값이 x인 원소가 존재한다면
else:
		print(count)
```


### 📍 출처
이것이 취업을 위한 코딩 테스트다 with 파이썬 - 나동빈